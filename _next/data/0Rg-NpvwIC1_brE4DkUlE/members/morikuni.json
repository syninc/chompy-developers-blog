{"pageProps":{"member":{"id":"morikuni","name":"morikuni","bio":"Go/GCP/アプリケーションアーキテクチャ/写真。カヤック ⇒ メルカリ ⇒ Chompy","avatarSrc":"/chompy-developers-blog/avatars/morikuni.jpeg","sources":["https://inukirom.hatenablog.com/rss","https://qiita.com/morikuni/feed"],"twitterUsername":"inukirom","githubUsername":"morikuni","websiteUrl":"https://y.at/%F0%9F%8C%95%F0%9F%94%A5%F0%9F%92%A6%F0%9F%8C%B2%F0%9F%92%B0"},"postItems":[{"title":"Go 2 Draft DesignsのError Handlingについて","contentSnippet":"はじめにgocon.connpass.comGo 2 Draft Designs フィードバック会に参加してきたのですが、その中のエラーハンドリングの話について思ったことを書きます。本家のGo 2 Draft Designsでは、handleとcheckによって次のようにエラーハンドリングができるようになると書かれています。func process(user string, files chan string) (n int, err error) {    handle err { return 0, fmt.Errorf(\"process: %v\", err)  }      // handler A    for i := 0; i < 3; i++ {        handle err { err = fmt.Errorf(\"attempt %d: %v\", i, err) } // handler B        handle err { err = moreWrapping(err) }                    // handler C        check do(something())  // check 1: handler chain C, B, A    }    check do(somethingElse())  // check 2: handler chain A}個人的にエラーハンドリングを簡単にかけるようにすることは賛成ですが、このやり方はよくないと思ったので別の方法を考えました。handle and checkのつらいところ上のコードに書かれたコメントにあるようにhandleにはスコープが存在し、1つの関数内に複数のhandleが書けるようになっています。さらにhandleはreturnを書かなければerrを上書きできるようになっており、check 1のコメントがある部分ではC, B, Aのhandleが実行されます。ただしcheck 2のコメントの部分ではAのhandleのみが実行されるようになっており、エラーが一体どのhandleで処理されるのかを意識しながらコーディングしなくてはなりません。考えた方法スコープを考えるのがつらいのであれば、関数スコープ外でhandleを定義できればよいのです。なのでhandlerというものを定義できるようにすることを考えました。// handlerと書くことでエラーハンドラーを定義できるhandler ParseError(err error) error { return errors.Wrap(err, “parse error“) }// クロージャーと同じようにhandlerを返すfuncを定義できるfunc WithMessage(message string) handler(err error) {    return handler(err error) error { returns errors.Wrap(err, message) }}// 常にnilを返すことでエラーを無視できるhandler Ignore(_ error) error { return nil }type MultiError struct {    Errors []error}// structのメソッドとしても定義できるhandler (me *MultiError) Append(err error) error {    me.Errors = append(me.Errors, err)    return nil}func (me *MultiError) Error() string {    return \"multi error\"}func doX() error {    // checkはhandlerを受け取り、関数の返り値のerrでhandlerを呼び出す。handlerの返り値がnilなら処理を継続、そうでなければその場でreturnする。    i1 := check ParseError strconv.ParseInt(“123”, 10, 64)    i2 := check WithMessage(“parse error”) strconv.ParseInt(“123”, 10, 64)    i3 := check Ignore strconv.ParseInt(“123”, 10, 64)    // structに生やすことで複数のエラーを簡単にまとめることもできる。    me := &MultiError{}    i4 := check me.Append strconv.ParseInt(“123”, 10, 64)    i5 := check me.Append strconv.ParseInt(“456”, 10, 64)    return me}公式のDraftと大きな違いはありません。handlerというfuncのようなものを定義できるようにするだけです。handlerはfunc(err error) errorという形で固定です。checkではhandlerを受け取り、関数の返り値のerrがerr != nilの場合のみhandlerを呼び出します。呼び出したhandlerの返り値がerr != nilの場合は、返ってきたerrをその場でreturnします。nilだった場合はなにもせずにそのまま処理を継続します。考え方としては、特別なinterfaceであるerrorと同じように特別なfuncであるhandlerを定義可能にしようというイメージです。なお、このhandlerを採用する場合、handler型が書かれているところではエラーハンドリングが行われることを理解できるので、checkという構文自体を消して次のように書くことも可能になると思います。i1 := ParseError strconv.ParseInt(“123”, 10, 64)checkを入れるかどうかは見やすさや、コンパイラの実装がやりやすいほうに倒せばいいかなと思います。追記\"Use functions as an error handler, Add syntactic sugar to remove duplicated if statement\"というタイトルで  Go2ErrorHandlingFeedback · golang/go Wiki · GitHub にFeedbackを書いておいた。Go Fridayで話したらhandler構文なくしてもいいんじゃないかということを言われたので、提案したproposalではhandlerをfuncにしてcheckのシンタックスシュガーのみを採用することにした。","link":"https://inukirom.hatenablog.com/entry/2018/09/27/234124","isoDate":"2018-09-27T14:41:24.000Z","dateMiliSeconds":1538059284000,"authorName":"morikuni","authorId":"morikuni"},{"title":"GoにおけるDI","contentSnippet":"Go4 Advent Calendar 2017 12日目の記事です。昨日(12/11)はgolang.tokyo #11でLTをしてきました。LTは時間の都合上「DIコンテナを使わないDI」というタイトルでしたが、この記事では「GoにおけるDI」をテーマに、もう少し広い範囲のことを書きます。DIとは？DIはDependency Injection(依存性の注入)の略称で、ある処理に必要なオブジェクト(や関数)を外部から注入(指定)できるようにする実装パターンです。依存するオブジェクトを注入すること自体を指す場合もあります。基本的には依存するオブジェクトをInterfaceとして定義し、Interfaceにのみ依存させることで、実装を入れ替えられるようにするというものです。なぜDIするか？DIする利点として挙げられるのは主に次の２点です。ユニットテストが書きやすくなるオブジェクト間の結合度を下げやすくなる一番大きいのはユニットテストが書きやすくなることです。依存先がInterfaceになっていることで、その実装を入れ替えることができ、テスト時にモックを使ったユニットテストができるようになります。また、Interfaceになっていることで、内部のフィールドにアクセスできなくなり、オブジェクト間の結合度が下げやすくなるという利点もあります。ただし、無闇にGetterやSetterを追加するとこの利点は失われてしまうので注意が必要です。GoでのDIでは本題のGoでDIするためにはどうすればいいのかに移ります。Goでは依存先をinterfaceとして定義し、structのフィールドとして持たせることによって、DIができるようになります。例題として、次のような機能を考えてみましょう。メールアドレスとパスワードでユーザーを作成し保存する成功したら登録完了メールを送信する実装するためには次のようなコードを書くことになるでしょう。type SignUpService interface {    SignUp(email, password string) error}type signUpService struct {}func (s signUpService) SignUp(email, password string) error {    // to be implemented}SignUpServiceはUserを保存する処理と、メールを送信する処理に依存します。なのでUserを保存する処理としてUserRepository、メールを送信するための処理としてMailerをinterfaceとして定義します。type UserRepository interface {    Save(u User) error}type Mailer interface {    SendEmail(to, message) error}この2つのinterfaceをstructのフィールドに持たせてSignUpServiceを完成させましょう。type signUpService struct {    repo   UserRepository    mailer Mailer}func (s signUpService) SignUp(email, password string) error {    u := NewUser(email, password)    if err := s.repo.Save(u); err != nil {        return err    }    return s.mailer.SendEmail(email, \"登録完了\")}func NewSignUpService(repo UserRepository, mailer Mailer) SignUpService {    return signUpService{        repo,        mailer,    }}これでSignUpServiceは依存先がinterfaceのみになったため、モックを使ったユニットテストが書けます。ただし、アプリケーションを実行するときにはこれで終わりではありません。UserRepositoryやMailerの実装を取得し、NewSignUpServiceに渡す必要があります。UserRepositoryとMailerのインスタンスを取得するためにはコンストラクタが必要なので用意します。具体的な内部実装は気にする必要はありません。func NewUserRepository(db DB) UserRepository {    ...}func NewMailer() {    ...}UserRepositoryはDBに依存しています。DBは*sql.DBのメソッドを定義したinterfaceだとしましょう。Mailerは依存がないため引数なしで実装を取得できます。次はこのコンストラクタを使い、どうやって依存関係を解決するかについて次の3つの方法を紹介します。mainに書くDIコンテナを使うDI用の関数を定義するmainに書く1つめはmainで全ての依存関係を解決する方法です。func main() {    db, err := sql.Open(\"db\", \"dsn\")    if err != nil {        panic(err)    }    repo := NewUserRepository(db)    mailer := NewMailer()    service := NewSignUpService(repo, mailer)    ...}シンプルですが、使用するオブジェクト数に比例してmainが肥大化していくという問題があります。DIコンテナを使う2つ目はDIコンテナを使う方法です。Javaなどでは一般的なんじゃないかと思いますが、Goでは使っているところを見たことがありません。例としてgoldiを使いますが、私も使ったことはないので間違っているところがあるかもしれません。goldiではyamlで依存関係を解決します。types:    db:        package: database/sql        type: *DB        factory: Open        arguments:            - \"db\"            - \"dsn\"    repository:        package: github.com/morikuni/hoge        type: UserRepository        factory: NewUserRepository        arguments:            - \"@db\"    mailer:        package: github.com/morikuni/hoge        type: Mailer        factory: NewMailer    service:        package: github.com/morikuni/hoge        type: SignUpService        factory: NewSignUpService        arguments:            - \"@repository\"            - \"@mailer\"goldigenというコマンドにこのyamlを渡すことでRegisterTypesという関数が生成されます。DIコンテナにこの関数を適用することで依存関係が解決できるようになります。func main() {    registry := goldi.NewTypeRegistry()    RegisterTypes(registry)    container := goldi.NewContainer(registry, nil)    service := container.MustGet(\"service\").(SignUpService)    ...}DIコンテナを使うことでmainが肥大化していくことはなくなります。ただし、DIコンテナの使い方を覚える必要があったり、最終的にはGoのコードになるといえyamlは直接コンパイルできないので、コンパイルエラーのフィードバックを得られるまでの手間が増えてしまうという問題があります。DI用の関数を定義する3つめはDI用の関数を用意する方法です。この関数をInject関数と呼ぶことにします。Inject関数は次のような関数です。オブジェクトを引数0個で取得できるようにするオブジェクトのコンストラクタに対して他のInject関数を使ってオブジェクトを注入するあるオブジェクトについて、依存先が引数0個で取得できれば、そのオブジェクトも引数0個で取得できるので、これを組み合わせるというものです。実際に例を見ていきましょう。func InjectDB() DB {    db, err := sql.Open(\"db\", \"dsn\")    if err != nil {        panic(err)    }    return db}func InjectUserRepository() UserRepository {    return NewUserRepository(        InjectDB(),    )}func InjectMailer() Mailer {    return NewMailer()}func InjectSignUpService() SignUpService {    return NewSignUpService(        InjectUserRepository(),        InjectMailer(),    )}func main() {    service := InjectSignUpService()    ...}最初にInjectDBを定義しています。これはsql.Openを使って*sql.DBを返す関数です。InjectDBを使うことでDBが引数0個で取得できるので、UserRepositoryも引数0個で取得できるようになります。同様にSignUpServiceもInjectRepositoryとInjectMailerを使うことで引数0個で取得できます。このようにInject関数を組み合わせること依存関係を解決するのがInject関数です。1つ気になるのは、InjectDB内でpanicを使っていることです。Goの文化としてはできる限りpanicを使わないことが望ましいと思いますが、Inject関数を使うのはmain関数内だけのはずです。つまりInject関数はアプリケーションの初期化の時だけに呼ばれることになります。sql.Openなどに失敗すると言うことは初期化に失敗したということなので、おかしな状態で起動するよりはpanicで起動に失敗してしまったほうがよいのではないかと思います。どうしてもpanicさせたくなければ、ログを吐いた後でos.Exitするという方法でも構いません。Inject関数を定義することの利点としては次のようなことが挙げられます。依存先が増減しても影響範囲はInject関数内のみ例: SignUpServiceがLoggerに依存するようになっても、InjectSignUpServiceに1行足すだけでよい実装が書かれるpackageが変わっても影響範囲はInject関数内のみ例: DBの実装がdatabase/sqlパッケージからdatastoreパッケージに変わってもInjectDBで呼び出すコンストラクタを変更するだけでよい (interfaceが同じ限りは)機能の追加やリファクタリングなどがやりやすくなるので、Inject関数を使う方法がよいのではないかと思います。最後に、Inject関数をどのパッケージに書くかということですが、私はdiパッケージを作るのをオススメします。専用のパッケージがあることによって、interfaceと実装の対応や、オブジェクトの注入など、依存関係に関するほとんどすべての責務を1つのパッケージに収めることができるからです。また、diパッケージがmain以外から依存されないようにすることによって、Cycle Importも起きにくくなります。まとめ依存するオブジェクトinterfaceにすることで実装を入れ替えることができ、ユニットテストが書きやすくなるInject関数を定義することでDIコンテナを使わずに依存関係を解決することができ、リファクタリングなどもしやすくなる私個人はアプリケーションアーキテクチャに興味があり、設計を試すリポジトリを公開しています。現時点では全然機能がありませんが、今回のDIに関するコードも含まれているので、より具体的なコードが見たければそちらを見てください。github.com質問などがあればお気軽にTwitterでどうぞ！ morikuni (@inukirom) | Twitter","link":"https://inukirom.hatenablog.com/entry/di-in-go","isoDate":"2017-12-12T01:09:00.000Z","dateMiliSeconds":1513040940000,"authorName":"morikuni","authorId":"morikuni"},{"title":"checkansiコマンドを追加しました","contentSnippet":"ANSIエスケープコードのGoラッパーであるaecにcheckansiコマンドを追加しました。checkansiを使うことで、お使いの端末でサポートされている文字の色付けとスタイルを確認することが出来ます。使い方aecのルートディレクトリに移動して実行してください。go run checkansi/main.goちなみにこの画像は、MacのTerminal.appで撮影しました。インストールインストールしていつでも使えるようにしたければ、以下のコマンドを実行してください。なお、$GOPATH/binにパスが通っている必要があります。go install github.com/morikuni/aec/checkansiインストールに成功したらcheckansiと入力するだけで実行できるようになっています。qiita.com","link":"https://inukirom.hatenablog.com/entry/2016/02/14/185831","isoDate":"2016-02-14T09:58:31.000Z","dateMiliSeconds":1455443911000,"authorName":"morikuni","authorId":"morikuni"},{"title":"GoでANSIエスケープコードを扱うライブラリを作った(色付け・カーソル移動等)","contentSnippet":"はじめにANSIエスケープコード(or エスケープシーケンス)とよばれる文字列を使うことで、端末上で文字に色を付けたり、文字のフォーマットを変更したり、カーソルを操作することができます。詳細は…","link":"https://qiita.com/morikuni/items/ad8d900f56ddeb223101","isoDate":"2016-01-26T08:07:13.000Z","dateMiliSeconds":1453795633000,"authorName":"morikuni","authorId":"morikuni"},{"title":"ユニットテストが書きやすい設計〜自家製モックを添えて〜","contentSnippet":"はじめにGoではinterfaceを使うことで機能と実装を分けることができます。関数やメソッドやがインターフェースにのみ依存するのであれば、テストの時にだけ実装を入れ替えることができ、テストし…","link":"https://qiita.com/morikuni/items/24c98e5d8116ab14fcdf","isoDate":"2016-01-17T06:29:42.000Z","dateMiliSeconds":1453012182000,"authorName":"morikuni","authorId":"morikuni"},{"title":"CLIのWebsocketクライアントを作ってみた","contentSnippet":"Websocketを使ったサーバを作ったときに、動作確認をJavaScriptで書くのが面倒なのでターミナル上でやりたいと思いました。wscatやwsshというツールが既にありますが、npmやpy…","link":"https://qiita.com/morikuni/items/943557ec049c90815ee1","isoDate":"2016-01-11T11:08:18.000Z","dateMiliSeconds":1452510498000,"authorName":"morikuni","authorId":"morikuni"},{"title":"importによってパッケージを拡張する方法(プラグイン)","contentSnippet":"概要Goでは以下のようなブランク識別子(アンダースコア)を使ったimportを見かけることがあります。import (    _ \"foo\")公式リファレンスには、An import decl…","link":"https://qiita.com/morikuni/items/e4e1543b070462aabdb5","isoDate":"2016-01-03T07:38:26.000Z","dateMiliSeconds":1451806706000,"authorName":"morikuni","authorId":"morikuni"}]},"__N_SSG":true}